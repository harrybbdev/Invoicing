# Introduction
An invoicing system I'm building as a technical demo. A full specification can be found in the root regarding functionality and features (which was very helpfully generated by ChatGPT). By following this specification and building it out as I go, the aim was to develop an app in a similar way to how it might be done for a small enterprise MVP. This helped refine my requirements gathering skills, as I treated ChatGPT as my domain expert/project manager and was able to ask it clarifying questions on the spec and have it updated regularly.

# Technical Concepts
As this is a technical demo first and foremost, I wanted to discuss each section of the codebase here and what techniques I used to build out each feature. Some of these concepts I wouldn't necessarily use in a real MVP - real world constraints mean that a more complex solution isn't viable or warranted in a lot of cases. I didn't have any such restraints here so tended towards the more "complex" side as a way of brushing up my skills for future projects.

## Architecture
### Vertical Slice Architecture
I am a massive fan of this architecture, as it scales extremely well with the complexity of the application. Each feature can be developed (and deployed if working in a microservices environment) completely independently, adearing to good code isolation and close grouping of related concepts (low coupling, high cohesion). Each "feature" in VSA is unable to reference any of the code in other features, meaning if it needs access to them, then services will need to be created in the calling feature that are able to access read only representations of the other feature's data. While this does seem like a pain, it also strictly enforces the separation between features, and prevents "spaghetti code" where all the features end up referencing each other to make things easier for developers in the short term. That will just cause more problems long term!

As mentioned, each feature is developed independently. This means that for one feature that is critical to your company (core subdomain), you might decide to build it out with Clean Architecture, Domain Driven Design, CQRS etc to really ensure it is  However for another run-of-the-mill feature that performs some basic CRUD functions, all of that other stuff would slow down development and be completely overkill. The beauty of VSA is that you can have the full enterprise-heavy feature developed in one way, while the.

### Modular Monoliths
A fancy name for a single solution that contains all of the features of your application in a single deployment. 

### Clean Architecture
This is very loosely used in the project, more so as a baseline rather than a strict adherance.
